/*Autogenerated file*/

#include "_proto.h"
#include "../../../../src/utLib/inc/_fmod.h"

#define TEST_STRING "Test message for write"
#define TEST_STRING_SIZE 22
#define TEST_FILE "/tmp/test"
void
test_fmod (void)
{

  bs_fmodCls rdF = NULL;
  bs_fmodCls rdwrF = NULL;
  int retCount = 0;
  char testBuffer[50];

  hdr ("Testing of fmod module started");

  retVal = bs_fmodInit (&rdF, iMObj);
  EXEC_TSTCASE (&tstCase, "Check for initization of the read file object.",
		retVal, retVal, ec2ES (retVal), 0);

  retVal = bs_fmodInit (&rdwrF, iMObj);
  EXEC_TSTCASE (&tstCase,
		"Check for initization of the read/write file object.",
		retVal, retVal, ec2ES (retVal), 0);

  retVal = bs_fCreate (rdF, TEST_FILE, 0755);
  EXEC_TSTCASE (&tstCase, "Check for the creation of a file.", retVal, retVal,
		ec2ES (retVal), 0);

  EXEC_SH (&tstCase, "test -e /tmp/test", "Checking if file exists.", 0);

  retVal = bs_fOpen (rdF, "/tmp/test", F_ASCII, FA_RD);
  EXEC_TSTCASE (&tstCase, "RD: Open the newly created file.", retVal, retVal,
		ec2ES (retVal), 0);

  memset (testBuffer, 0, sizeof (testBuffer));

  retVal = bs_fRead (rdF, &testBuffer, 10, &retCount);
  EXEC_TSTCASE (&tstCase,
		"RD: Check read for a 0 size file and check EOF handling.",
		retVal, retCount, ec2ES (retVal), 0);

  retVal = strlen (testBuffer);
  EXEC_TSTCASE (&tstCase, "RD: Check the returned buffer content size.",
		(retVal == 0), retVal,
		"Buffer not empty for a read from file size 0", 0);

  memcpy (testBuffer, TEST_STRING, TEST_STRING_SIZE);

  retVal = bs_fWrite (rdF, &testBuffer, TEST_STRING_SIZE, &retCount);
  EXEC_TSTCASE (&tstCase, "RD: Write on a file opened in Read only mode.",
		(retVal < 0), retVal, ec2ES (retVal), 0);

  memset (testBuffer, 0, sizeof (testBuffer));

  retVal = bs_fRead (rdF, &testBuffer, 10, &retCount);
  EXEC_TSTCASE (&tstCase,
		"RD: Check read for a 0 size file and check EOF handling.",
		retVal, retCount, ec2ES (retVal), 0);

  //;
  EXEC_TSTCASE (&tstCase, "RD: Check the returned count value.",
		(retCount == 0), retCount, "retCount not 0", 0);

  retVal = strlen (testBuffer);
  EXEC_TSTCASE (&tstCase, "RD: Check the returned buffer content size.",
		(retVal == 0), retVal,
		"Buffer not empty for a read from file size 0", 0);

  retVal = bs_fOpen (rdwrF, "/tmp/test", F_ASCII, FA_WR);
  EXEC_TSTCASE (&tstCase, "WR: Open the test file in WR only mode.", retVal,
		retVal, ec2ES (retVal), 0);

  memcpy (testBuffer, TEST_STRING, TEST_STRING_SIZE);

  retVal = bs_fWrite (rdwrF, &testBuffer, TEST_STRING_SIZE, &retCount);
  EXEC_TSTCASE (&tstCase, "WR: Write on a file opened in Write only mode.",
		retVal, retVal, ec2ES (retVal), 0);

  //;
  EXEC_TSTCASE (&tstCase, "WR: Check the return count size.",
		(retCount == TEST_STRING_SIZE), retCount,
		"retCount value mismatches with the value written", 0);

  EXEC_SH (&tstCase,
	   "printf 'Test message for write'|diff - /tmp/test >/dev/null",
	   "Checking file contents for the written message.", 0);

  memset (testBuffer, 0, sizeof (testBuffer));

  retVal = bs_fRead (rdwrF, &testBuffer, TEST_STRING_SIZE, &retCount);
  EXEC_TSTCASE (&tstCase, "WR: Check read for a file opened in WR only mode.",
		(retVal < 0), retVal, ec2ES (retVal), 0);

  retVal = strlen (testBuffer);
  EXEC_TSTCASE (&tstCase, "WR: Check the returned buffer content size.",
		(retVal == 0), retVal,
		"Buffer not empty for a failed read from file.", 0);

  retVal = strlen (testBuffer);
  EXEC_TSTCASE (&tstCase, "WR: Check the returned buffer count size.",
		(retCount == 0), retCount, "retCount not 0.", 0);

  memset (testBuffer, 0, sizeof (testBuffer));

  retVal = bs_fRead (rdF, &testBuffer, TEST_STRING_SIZE, &retCount);
  EXEC_TSTCASE (&tstCase, "RD: Check read for a written file.", retVal,
		retCount, ec2ES (retVal), 0);

  retVal = bs_fRead (rdF, &testBuffer, TEST_STRING_SIZE, &retCount);
  EXEC_TSTCASE (&tstCase, "RD: Check the returned buffer count size.",
		(retCount == TEST_STRING_SIZE), retCount,
		"retCount not matching.", 0);

  retVal = strlen (testBuffer);
  EXEC_TSTCASE (&tstCase, "RD: Check the returned buffer content size.",
		(retVal == TEST_STRING_SIZE), retVal,
		"Buffer size not valid.", 0);

  retVal = strcmp (testBuffer, TEST_STRING);
  EXEC_TSTCASE (&tstCase, "Check the returned buffer contents.",
		(retVal == 0), retVal, "Buffer not valid.", 0);

  retVal = bs_fClose (rdwrF);
  EXEC_TSTCASE (&tstCase, "Close the opened file.", retVal, retVal,
		ec2ES (retVal), 0);

  retVal = bs_fClose (rdF);
  EXEC_TSTCASE (&tstCase, "Close the opened file.", retVal, retVal,
		ec2ES (retVal), 0);
  retVal = bs_fClose (rdF);
  EXEC_TSTCASE (&tstCase, "Close the file again.", retVal, retVal,
		ec2ES (retVal), 0);

  retVal = bs_fmodFin (&rdF, iMObj);
  EXEC_TSTCASE (&tstCase, "Check for Finalization of the read file object.",
		retVal, retVal, ec2ES (retVal), 0);

  retVal = bs_fmodFin (&rdwrF, iMObj);
  EXEC_TSTCASE (&tstCase,
		"Check for Finalization of the read/write file object.",
		retVal, retVal, ec2ES (retVal), 0);

  hdr ("Testing of fmod module compleated");
}
